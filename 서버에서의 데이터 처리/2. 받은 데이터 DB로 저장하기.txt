DB로 저장할 때 여러 방법이 있지만, 기본적인 H2 DB와 Repository로 설명하겠다.



앞서 봤던 DTO 데이터가 DB로 저장되기 위해 JPA(Java Persistence API)를 사용할 수 있다. JPA는 자바 언어로 DB에 명령을 내리는 도구로, 데이터를 객체 지향적으로 관리할 수 있게 해준다. 즉, 클라이언트 데이터 -> DTO -> 서버(Controller, ...) -> Entity -> (JAP) -> DB(SQL) 관리 인 셈이다.

DTO가 최종적으로 DB로 저장되기 위해서는 몇가지 과정을 거쳐야 한다. 그 과정은 DTO -> Entity -> Repository 인터페이스 -> DB 작성.
Entity: DB에 저장될 실질적인 행렬 형태의 데이터이다. 자바 객체를 DB가 이해할 수 있도록 만든 것으로, 이를 기반으로 테이블이 만들어진다.
Repository 인터페이스: 자바 인터페이스로, Entity 객체를 DB에 쓰고, 읽고, 업데이트하고, 삭제할 수 있는 기능을 제공하는 인터페이스다.(CRUD, Create, Read, Update, Delete)



1. 우선 위에서 봤든 DTO가 Entity로 변환되는 과정 필요하다. 다음 코드를 보자.
 [ArticleEntity.java]
package com.example.firstproject.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.Id;

@Entity
public class ArticleEntity {
    @Id
    @GeneratedValue
    private Long id;

    @Column
    private String title;
    @Column
    private String content;

    public ArticleEntity(Long id, String title, String content) {
        this.id = id;
        this.title = title;
        this.content = content;
    }
}

 [ArticleForm.java] 중 일부
  ...
      public ArticleEntity toEntity() {
        return new ArticleEntity(null, title, content);
    }
  ...

우선 Entity 객체를 보면 Id가 가장 먼저 보인다. DB에 동일한 데이터가 있어도 구분할 수 있어야 하므로 고윳값인 Id가 그 역할을 한다. 그 기능을 하겠다고 알려주는 어노테이션이 @Id이다. 바로 밑에 @GeneratedValue는 id값을 자동적으로 관리하겠다는 말이다. 관리자가 일일이 데이터에 id를 부여하지 않아도 DB 관리 과정에서 자동적으로 각 데이터마다 1씩 증가하는 id로 관리하겠다는 의미이다. 이후 @Column하고 하나의 데이터가 일대일 대응된다. 이는 해당 데이터를 열로 만들겠다는 말이다. 위의 데이터를 예시로 들면 id | title | content 형식으로 아래로 한줄 한줄 차곡차곡 데이터가 쌓인다.
[ArticleForm.java]코드를 보면, DTO 클래스 메서드로 toEntity 메서드가 있음을 볼 수 있다. 사용법은 바로 다음에 알려주겠다.


3. toEntity() 사용법
 [ArticleController.java] 중 일부
     @PostMapping("/makeNew")
    public String test(ArticleForm art) {
        System.out.println(art.toString());

        ArticleEntity a1 = art.toEntity();
        System.out.println(a1.toString());

        return "";
    }
실행하면 ArticleEntity{id=null, title='abc', content='123'}와 같이 뜬다. 아직 이 데이터를 DB에 넣지 않았으므로 id는 할당되지 않은 값임을 볼 수 있다.


4. 지금까지 DTO -> Entity과정을 살펴봤고, Repository 인터페이스를 활용해 DB에 작성하는 법을 살펴보겠다.
 [ArticleRepository.java]
package com.example.firstproject.repository;

import com.example.firstproject.entity.ArticleEntity;
import org.springframework.data.repository.CrudRepository;

public interface ArticleRepository extends CrudRepository<ArticleEntity, Long> {
}

CrudRepository는 JPA에서 제공하는 DB CRUD기능을 제공하는 인터페이스다. 저렇게 선언하면 메서드들을 그대로 사용할 수 있다. CrudRepository뒤에 두 제네릭 요소가 필요한데, 처음은 대상 엔티티의 클래스 타입, 두 번째는 관리 대상의 엔티티의 대푯값(여기는 id값)이다.

 [ArticleController.java]
package com.example.firstproject.controller;

import com.example.firstproject.dto.ArticleForm;
import com.example.firstproject.entity.ArticleEntity;
import com.example.firstproject.repository.ArticleRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;

@Controller
public class ArticleController {
    @Autowired
    private ArticleRepository artRepo;

    @GetMapping("/new")
    public String page1() {
        return "new";
    }

    @PostMapping("/makeNew")
    public String test(ArticleForm art) {
        System.out.println(art.toString());

        ArticleEntity a1 = art.toEntity();
        System.out.println(a1.toString());

        ArticleEntity s1 = artRepo.save(a1);
        System.out.println(s1.toString());

        return "";
    }
}

이제 컨트롤러에서 Repository를 이용해서 DB에 저장해보자. 엔티티도 변환한 a1을 artRepo.save()메서드를 활용하면 DB에 저장하며, 방금 DB에 저장한 데이터를 그대로 반환한다. 방금 저장한 행을 반환하는 것이다. 실행해보면 ArticleEntity{id=1, title='abc', content='123'}가 뜨는데, DB에 저장되므로 @GeneratedValue에 의해 id값이 자동으로 카운트가 올라간 것이다. 이렇게 Repository를 활용해서 Entity를 DB에 저장하는 방법을 알아봤다.
